{
  "contractName": "JoinSplitInterface",
  "abi": [
    {
      "constant": true,
      "inputs": [],
      "name": "EIP712_DOMAIN_HASH",
      "outputs": [
        {
          "name": "",
          "type": "bytes32"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function",
      "signature": "0xe306f779"
    },
    {
      "inputs": [],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "constructor",
      "signature": "constructor"
    },
    {
      "constant": true,
      "inputs": [
        {
          "name": "",
          "type": "bytes"
        },
        {
          "name": "",
          "type": "address"
        },
        {
          "name": "",
          "type": "uint256[6]"
        }
      ],
      "name": "validateJoinSplit",
      "outputs": [
        {
          "name": "",
          "type": "bytes"
        }
      ],
      "payable": false,
      "stateMutability": "pure",
      "type": "function",
      "signature": "0x7a26becd"
    }
  ],
  "bytecode": "0x608060405234801561001057600080fd5b50604080517f454950373132446f6d61696e28000000000000000000000000000000000000006020808301919091527f737472696e67206e616d652c0000000000000000000000000000000000000000602d8301527f737472696e672076657273696f6e2c000000000000000000000000000000000060398301527f6164647265737320766572696679696e67436f6e74726163740000000000000060488301527f29000000000000000000000000000000000000000000000000000000000000006061830152825160428184030181526062830180855281519183019190912060a28401855260199091527f415a5445435f43525950544f4752415048595f454e47494e450000000000000060829093019290925282518084018452600181527f3100000000000000000000000000000000000000000000000000000000000000908201528251808201929092527fc8066e2c715ce196630b273cd256d8959d5b9fefc55e9e6d999fb0f08bb7f75f828401527fc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc66060830152306080808401919091528351808403909101815260a090920190925280519101206000556101ae806101dd6000396000f3fe608060405234801561001057600080fd5b5060043610610052577c010000000000000000000000000000000000000000000000000000000060003504637a26becd8114610057578063e306f77914610158575b600080fd5b6100e3600480360361010081101561006e57600080fd5b81019060208101813564010000000081111561008957600080fd5b82018360208201111561009b57600080fd5b803590602001918460018302840111640100000000831117156100bd57600080fd5b919350915073ffffffffffffffffffffffffffffffffffffffff81351690602001610172565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561011d578181015183820152602001610105565b50505050905090810190601f16801561014a5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61016061017c565b60408051918252519081900360200190f35b6060949350505050565b6001548156fea165627a7a72305820acc659773ef713f65d5f434c3b48030a0434a6b4127cf42503f4cd50d0fc11760029",
  "deployedBytecode": "0x608060405234801561001057600080fd5b5060043610610052577c010000000000000000000000000000000000000000000000000000000060003504637a26becd8114610057578063e306f77914610158575b600080fd5b6100e3600480360361010081101561006e57600080fd5b81019060208101813564010000000081111561008957600080fd5b82018360208201111561009b57600080fd5b803590602001918460018302840111640100000000831117156100bd57600080fd5b919350915073ffffffffffffffffffffffffffffffffffffffff81351690602001610172565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561011d578181015183820152602001610105565b50505050905090810190601f16801561014a5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61016061017c565b60408051918252519081900360200190f35b6060949350505050565b6001548156fea165627a7a72305820acc659773ef713f65d5f434c3b48030a0434a6b4127cf42503f4cd50d0fc11760029",
  "sourceMap": "108:350:2:-;;;250:23;8:9:-1;5:2;;;30:1;27;20:12;5:2;-1:-1;1133:160:11;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;22:32:-1;26:21;;;22:32;6:49;;1133:160:11;;;;;;1123:171;;;;;;;;;1611:18;;;;;1133:160;1611:18;;;;;;;;;;;;1661:21;;;;;;;1133:160;1661:21;;;;;;;1516:223;;;;;;;;;1595:36;1516:223;;;;1645:39;1516:223;;;;1722:4;1516:223;;;;;;;;;;26:21:-1;;;22:32;;;6:49;;1516:223:11;;;;;;;1506:234;;;;;-1:-1:-1;1485:255:11;108:350:2;;;;;;",
  "deployedSourceMap": "108:350:2:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;108:350:2;;;;;;;;;;;;;;;;;;;;;;;;283:173;;;;;;13:3:-1;8;5:12;2:2;;;30:1;27;20:12;2:2;283:173:2;;;;;;;;21:11:-1;5:28;;2:2;;;46:1;43;36:12;2:2;283:173:2;;35:9:-1;28:4;12:14;8:25;5:40;2:2;;;58:1;55;48:12;2:2;283:173:2;;;;;;100:9:-1;95:1;81:12;77:20;67:8;63:35;60:50;39:11;25:12;22:29;11:107;8:2;;;131:1;128;121:12;8:2;283:173:2;;-1:-1:-1;283:173:2;-1:-1:-1;283:173:2;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8:100:-1;33:3;30:1;27:10;8:100;;;90:11;;;84:18;71:11;;;64:39;52:2;45:10;8:100;;;12:14;283:173:2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;210:33;;;:::i;:::-;;;;;;;;;;;;;;;;283:173;435:12;283:173;;;;;;:::o;210:33::-;;;;:::o",
  "source": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./JoinSplitABIEncoder.sol\";\nimport \"../../../libs/LibEIP712.sol\";\n\ncontract JoinSplitInterface is LibEIP712 {\n    /* solhint-disable-next-line var-name-mixedcase */\n    bytes32 public EIP712_DOMAIN_HASH;\n\n    constructor() public {}\n    \n    function validateJoinSplit(\n        bytes calldata, \n        address, \n        uint[6] calldata\n    ) \n        external \n        pure \n        returns (bytes memory) \n    {}\n}\n\n/**\n * @title Library to validate AZTEC zero-knowledge proofs\n * @author Zachary Williamson, AZTEC\n * @dev Don't include this as an internal library. This contract uses a static memory table to cache\n * elliptic curve primitives and hashes.\n * Calling this internally from another function will lead to memory mutation and undefined behaviour.\n * The intended use case is to call this externally via `staticcall`.\n * External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no\n * storage and makes no external calls (other than to precompiles)\n * Copyright Spilsbury Holdings Ltd 2018. All rights reserved.\n * We will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\n * Our full vision of the protocol includes confidential cross-asset interactions via our\n * family of AZTEC zero-knowledge proofs\n * and the AZTEC token standard, stay tuned for updates!\n **/\ncontract JoinSplit is LibEIP712 {\n\n    /**\n     * @dev AZTEC will take any transaction sent to it and attempt to validate a zero knowledge proof.\n     * If the proof is not valid, the transaction will throw.\n     * @notice See AZTECInterface for how method calls should be constructed.\n     * 'Cost' of raw elliptic curve primitives for a transaction:\n     * 260,700 gas + (124,500 * number of input notes) + (167,600 * number of output notes).\n     * For a basic 'joinSplit' with 2 inputs and 2 outputs = 844,900 gas.\n     * AZTEC is written in YUL to enable manual memory management and for other efficiency savings.\n     **/\n    function() external payable {\n        assembly {\n            // We don't check for function signatures,\n            // there's only one function that ever gets called: validateJoinSplit()\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract\n            // through a compatible ABI\n            validateJoinSplit()\n\n            /**\n             * New calldata map\n             * 0x04:0x24      = calldata location of proofData byte array\n             * 0x24:0x44      = message sender\n             * 0x44:0x64      = h_x\n             * 0x64:0x84      = h_y\n             * 0x84:0xa4      = t2_x0\n             * 0xa4:0xc4      = t2_x1\n             * 0xc4:0xe4      = t2_y0\n             * 0xe4:0x104     = t2_y1\n             * 0x104:0x124    = length of proofData byte array\n             * 0x124:0x144    = m\n             * 0x144:0x164    = challenge\n             * 0x164:0x184    = publicOwner\n             * 0x184:0x1a4    = offset in byte array to notes\n             * 0x1a4:0x1c4    = offset in byte array to inputSignatures\n             * 0x1c4:0x1e4    = offset in byte array to outputOwners\n             * 0x1e4:0x204    = offset in byte array to metadata\n             */\n            function validateJoinSplit() {\n                mstore(0x80, calldataload(0x44))\n                mstore(0xa0, calldataload(0x64))\n                let notes := add(0x104, calldataload(0x184))\n                let m := calldataload(0x124)\n                let n := calldataload(notes)\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let challenge := mod(calldataload(0x144), gen_order)\n\n                // validate m <= n\n                if gt(m, n) { mstore(0x00, 404) revert(0x00, 0x20) }\n\n                // recover k_{public} and calculate k_{public}\n                let kn := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n\n                // add kn and m to final hash table\n                mstore(0x2a0, calldataload(0x24))\n                mstore(0x2c0, kn)\n                mstore(0x2e0, m)\n                mstore(0x300, calldataload(0x164))\n                /* mstore(0x00, m)\n                mstore(0x20, n)\n                mstore(0x40, kn)\n                mstore(0x60, calldataload(0x24))\n                return(0x00, 0x80) */\n                kn := mulmod(sub(gen_order, kn), challenge, gen_order) // we actually want c*k_{public}\n                hashCommitments(notes, n)\n                let b := add(0x320, mul(n, 0x80))\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n                //  which adds some minor alterations\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1,\n                //  which adds some minor alterations\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                // Get the calldata index of this note\n                let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                // Define variables k, a and c.\n                // If i <= m then\n                //   k = kBar_i\n                //   a = aBar_i\n                //   c = challenge\n                // If i > m then we add a modification for the pairing optimization\n                //   k = kBar_i * x_i\n                //   a = aBar_i * x_i\n                //   c = challenge * x_i\n                // Set j = i - (m + 1).\n                // x_0 = 1\n                // x_1 = keccak256(input string)\n                // all other x_{j} = keccak256(x_{j-1})\n                // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n                // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n                // We validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n                // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n                // a sum of commitment points to be evaluated in one pairing comparison\n                let k\n                let a := calldataload(add(noteIndex, 0x20))\n                let c := challenge\n\n                // We don't transmit kBar_{n-1} in the proof to save space, instead we derive it from the\n                // homomorphic sum condition: \\sum_{i=0}^{m-1}\\bar{k}_i = \\sum_{i=m}^{n-1}\\bar{k}_i + k_{public}c, \n                // We can recover \\bar{k}_{n-1}.\n                // If m=n then \\bar{k}_{n-1} = \\sum_{i=0}^{n-1}\\bar{k}_i + k_{public}\n                // else \\bar{k}_{n-1} = \\sum_{i=0}^{m-1}\\bar{k}_i - \\sum_{i=m}^{n-1}\\bar{k}_i - k_{public}\n                switch eq(add(i, 0x01), n)\n                case 1 {\n                    k := kn\n\n                    // if all notes are input notes, invert k\n                    if eq(m, n) {\n                        k := sub(gen_order, k)\n                    }\n                }\n                case 0 { k := calldataload(noteIndex) }\n\n                // Check this commitment is well formed...\n                validateCommitment(noteIndex, k, a)\n\n                // If i > m then this is an output note.\n                // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n                switch gt(add(i, 0x01), m)\n                case 1 {\n\n                    // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n                    kn := addmod(kn, sub(gen_order, k), gen_order)\n                    let x := mod(mload(0x00), gen_order)\n                    k := mulmod(k, x, gen_order)\n                    a := mulmod(a, x, gen_order)\n                    c := mulmod(challenge, x, gen_order)\n\n                    // calculate x_{j+1}\n                    mstore(0x00, keccak256(0x00, 0x20))\n                }\n                case 0 {\n\n                    // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\n                    kn := addmod(kn, k, gen_order)\n                }\n            \n                // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n                // Memory map:\n                // 0x20: \\gamma_iX\n                // 0x40: \\gamma_iY\n                // 0x60: k_i\n                // 0x80: hX\n                // 0xa0: hY\n                // 0xc0: a_i\n                // 0xe0: \\sigma_iX\n                // 0x100: \\sigma_iY\n                // 0x120: -c\n                calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n                calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n                mstore(0x120, sub(gen_order, c)) \n                mstore(0x60, k)\n                mstore(0xc0, a)\n\n                // Call bn128 scalar multiplication precompiles\n                // Represent point + multiplication scalar in 3 consecutive blocks of memory\n                // Store \\sigma_i^{-c} at 0x1a0:0x200\n                // Store \\gamma_i^{k} at 0x120:0x160\n                // Store h^{a} at 0x160:0x1a0\n                let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n                result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n                result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n                // Call bn128 group addition precompiles\n                // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n                // Store result of addition at 0x160:0x1a0\n                result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n                // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n                // Store resulting point B at memory index b\n                result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n                // We have \\sigma^{-c} at 0x1a0:0x200\n                // And \\sigma_{acc} at 0x1e0:0x200\n                // If i = m + 1 (i.e. first output note)\n                // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n                if eq(i, m) {\n                    mstore(0x260, mload(0x20))\n                    mstore(0x280, mload(0x40))\n                    mstore(0x1e0, mload(0xe0))\n                    mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n                }\n\n                // If i > m + 1 (i.e. subsequent output notes)\n                // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n                // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n                if gt(i, m) {\n                    mstore(0x60, c)\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n                    // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n                    result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n                    // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n                    result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n                }\n\n                // throw transaction if any calls to precompiled contracts failed\n                if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n                    b := add(b, 0x40) // increase B pointer by 2 words\n                }\n\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\n                // a JoinSplit transaction. We can inductively assume that all input notes\n                // are well-formed AZTEC commitments and do not need to validate the implicit range proof\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\n                if lt(m, n) {\n                    validatePairing(0x84)\n                }\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n                // starting at 0x2a0, of size (b - 0x2a0).\n                // Hash this block to reconstruct the initial challenge and validate that they match\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n                if iszero(eq(expected, challenge)) {\n\n                    // No! Bad! No soup for you!\n                    mstore(0x00, 404)\n                    revert(0x00, 0x20)\n                }\n\n                // Great! All done. This is a valid proof, so fall through out of the assembly block\n                // so that we can call `ABIEncoder.encodeAndExit`\n            }\n\n            /**        \n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n             * @notice we don't hard-code t2 so that contracts that call this library can use\n             * different trusted setups.\n             **/\n            function validatePairing(t2) {\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let t2_x_1 := calldataload(t2)\n                let t2_x_2 := calldataload(add(t2, 0x20))\n                let t2_y_1 := calldataload(add(t2, 0x40))\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n                // check provided setup pubkey is not zero or g2\n                if or(or(or(or(or(or(or(\n                    iszero(t2_x_1),\n                    iszero(t2_x_2)),\n                    iszero(t2_y_1)),\n                    iszero(t2_y_2)),\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n                {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n\n                // store coords in memory\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n                // to what precompile expects\n                // We can overwrite the memory we used previously as this function is called at the\n                // end of the validation routine.\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n                mstore(0x140, t2_x_1)\n                mstore(0x120, t2_x_2)\n                mstore(0x180, t2_y_1)\n                mstore(0x160, t2_y_2)\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n                if or(iszero(success), iszero(mload(0x20))) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n             * and that signatures 'k' and 'a' are modulo the order of the curve.\n             * Transaction will throw if this is not the case.\n             * @param note the calldata loation of the note\n             **/\n            function validateCommitment(note, k, a) {\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let gammaX := calldataload(add(note, 0x40))\n                let gammaY := calldataload(add(note, 0x60))\n                let sigmaX := calldataload(add(note, 0x80))\n                let sigmaY := calldataload(add(note, 0xa0))\n                if iszero(\n                    and(\n                        and(\n                        and(\n                            eq(mod(a, gen_order), a), // a is modulo generator order?\n                            gt(a, 1)                  // can't be 0 or 1 either!\n                        ),\n                        and(\n                            eq(mod(k, gen_order), k), // k is modulo generator order?\n                            gt(k, 1)                  // and not 0 or 1\n                        )\n                        ),\n                        and(\n                        eq( // y^2 ?= x^3 + 3\n                            addmod(\n                                mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order),\n                                3,\n                                field_order\n                            ),\n                            mulmod(sigmaY, sigmaY, field_order)\n                        ),\n                        eq( // y^2 ?= x^3 + 3\n                            addmod(\n                                mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n                                3,\n                                field_order\n                            ),\n                            mulmod(gammaY, gammaY, field_order)\n                        )\n                        )\n                    )\n                ) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n             * This is used both as an input to validate the challenge `c` and also to\n             * generate pseudorandom relationships\n             * between commitments for different outputNotes, so that we can combine them\n             * into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\n             * @param notes calldata location notes\n             * @param n number of notes\n             **/\n            function hashCommitments(notes, n) {\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n                calldatacopy(add(0x320, mul(i, 0x80)), index, 0x80)\n                }\n                mstore(0x00, keccak256(0x320, mul(n, 0x80)))\n            }\n        }\n\n        // if we've reached here, we've validated the join split transaction and haven't thrown an error.\n        // Encode the output according to the ACE standard and exit.\n        JoinSplitABIEncoder.encodeAndExit(EIP712_DOMAIN_HASH);\n    }\n}\n",
  "sourcePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/JoinSplit/JoinSplit.sol",
  "ast": {
    "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/JoinSplit/JoinSplit.sol",
    "exportedSymbols": {
      "JoinSplit": [
        1109
      ],
      "JoinSplitInterface": [
        1095
      ]
    },
    "id": 1110,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1070,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:2"
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/JoinSplit/JoinSplitABIEncoder.sol",
        "file": "./JoinSplitABIEncoder.sol",
        "id": 1071,
        "nodeType": "ImportDirective",
        "scope": 1110,
        "sourceUnit": 1144,
        "src": "33:35:2",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/libs/LibEIP712.sol",
        "file": "../../../libs/LibEIP712.sol",
        "id": 1072,
        "nodeType": "ImportDirective",
        "scope": 1110,
        "sourceUnit": 1939,
        "src": "69:37:2",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 1073,
              "name": "LibEIP712",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 1938,
              "src": "139:9:2",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_LibEIP712_$1938",
                "typeString": "contract LibEIP712"
              }
            },
            "id": 1074,
            "nodeType": "InheritanceSpecifier",
            "src": "139:9:2"
          }
        ],
        "contractDependencies": [
          1938
        ],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 1095,
        "linearizedBaseContracts": [
          1095,
          1938
        ],
        "name": "JoinSplitInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "constant": false,
            "id": 1076,
            "name": "EIP712_DOMAIN_HASH",
            "nodeType": "VariableDeclaration",
            "scope": 1095,
            "src": "210:33:2",
            "stateVariable": true,
            "storageLocation": "default",
            "typeDescriptions": {
              "typeIdentifier": "t_bytes32",
              "typeString": "bytes32"
            },
            "typeName": {
              "id": 1075,
              "name": "bytes32",
              "nodeType": "ElementaryTypeName",
              "src": "210:7:2",
              "typeDescriptions": {
                "typeIdentifier": "t_bytes32",
                "typeString": "bytes32"
              }
            },
            "value": null,
            "visibility": "public"
          },
          {
            "body": {
              "id": 1079,
              "nodeType": "Block",
              "src": "271:2:2",
              "statements": []
            },
            "documentation": null,
            "id": 1080,
            "implemented": true,
            "kind": "constructor",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1077,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "261:2:2"
            },
            "returnParameters": {
              "id": 1078,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "271:0:2"
            },
            "scope": 1095,
            "src": "250:23:2",
            "stateMutability": "nonpayable",
            "superFunction": null,
            "visibility": "public"
          },
          {
            "body": {
              "id": 1093,
              "nodeType": "Block",
              "src": "454:2:2",
              "statements": []
            },
            "documentation": null,
            "id": 1094,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "validateJoinSplit",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1089,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1082,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "319:14:2",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1081,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "319:5:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1084,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "344:7:2",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 1083,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "344:7:2",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1088,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "362:16:2",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$6_calldata_ptr",
                    "typeString": "uint256[6]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 1085,
                      "name": "uint",
                      "nodeType": "ElementaryTypeName",
                      "src": "362:4:2",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 1087,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "36",
                      "id": 1086,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "367:1:2",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "6"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "362:7:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$6_storage_ptr",
                      "typeString": "uint256[6]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "309:75:2"
            },
            "returnParameters": {
              "id": 1092,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1091,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "435:12:2",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1090,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "435:5:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "434:14:2"
            },
            "scope": 1095,
            "src": "283:173:2",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1110,
        "src": "108:350:2"
      },
      {
        "baseContracts": [
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 1096,
              "name": "LibEIP712",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 1938,
              "src": "1432:9:2",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_LibEIP712_$1938",
                "typeString": "contract LibEIP712"
              }
            },
            "id": 1097,
            "nodeType": "InheritanceSpecifier",
            "src": "1432:9:2"
          }
        ],
        "contractDependencies": [
          1938
        ],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC zero-knowledge proofs\n@author Zachary Williamson, AZTEC\n@dev Don't include this as an internal library. This contract uses a static memory table to cache\nelliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory mutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`.\nExternal calls to OptimizedAZTEC can be treated as pure functions as this contract contains no\nstorage and makes no external calls (other than to precompiles)\nCopyright Spilsbury Holdings Ltd 2018. All rights reserved.\nWe will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\nOur full vision of the protocol includes confidential cross-asset interactions via our\nfamily of AZTEC zero-knowledge proofs\nand the AZTEC token standard, stay tuned for updates!*",
        "fullyImplemented": true,
        "id": 1109,
        "linearizedBaseContracts": [
          1109,
          1938
        ],
        "name": "JoinSplit",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1107,
              "nodeType": "Block",
              "src": "2070:17076:2",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1100,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateJoinSplit()\n    function validateJoinSplit()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x184))\n        let m := calldataload(0x124)\n        let n := calldataload(notes)\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x144), gen_order)\n        if gt(m, n)\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n        let kn := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n        mstore(0x2a0, calldataload(0x24))\n        mstore(0x2c0, kn)\n        mstore(0x2e0, m)\n        mstore(0x300, calldataload(0x164))\n        kn := mulmod(sub(gen_order, kn), challenge, gen_order)\n        hashCommitments(notes, n)\n        let b := add(0x320, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch eq(add(i, 0x01), n)\n            case 1 {\n                k := kn\n                if eq(m, n)\n                {\n                    k := sub(gen_order, k)\n                }\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            switch gt(add(i, 0x01), m)\n            case 1 {\n                kn := addmod(kn, sub(gen_order, k), gen_order)\n                let x := mod(mload(0x00), gen_order)\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n                mstore(0x00, keccak256(0x00, 0x20))\n            }\n            case 0 {\n                kn := addmod(kn, k, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, m)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, m)\n            {\n                mstore(0x60, c)\n                result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        if lt(m, n)\n        {\n            validatePairing(0x84)\n        }\n        let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x320, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x320, mul(n, 0x80)))\n    }\n}",
                  "src": "2080:17025:2"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [
                      {
                        "argumentTypes": null,
                        "id": 1104,
                        "name": "EIP712_DOMAIN_HASH",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1864,
                        "src": "19120:18:2",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bytes32",
                          "typeString": "bytes32"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bytes32",
                          "typeString": "bytes32"
                        }
                      ],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1101,
                        "name": "JoinSplitABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1120,
                        "src": "19086:19:2",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_JoinSplitABIEncoder_$1120_$",
                          "typeString": "type(library JoinSplitABIEncoder)"
                        }
                      },
                      "id": 1103,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1119,
                      "src": "19086:33:2",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_view$_t_bytes32_$returns$__$",
                        "typeString": "function (bytes32) view"
                      }
                    },
                    "id": 1105,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "19086:53:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1106,
                  "nodeType": "ExpressionStatement",
                  "src": "19086:53:2"
                }
              ]
            },
            "documentation": "@dev AZTEC will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction will throw.\n@notice See AZTECInterface for how method calls should be constructed.\n'Cost' of raw elliptic curve primitives for a transaction:\n260,700 gas + (124,500 * number of input notes) + (167,600 * number of output notes).\nFor a basic 'joinSplit' with 2 inputs and 2 outputs = 844,900 gas.\nAZTEC is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1108,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1098,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "2050:2:2"
            },
            "returnParameters": {
              "id": 1099,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "2070:0:2"
            },
            "scope": 1109,
            "src": "2042:17104:2",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1110,
        "src": "1410:17738:2"
      }
    ],
    "src": "0:19149:2"
  },
  "legacyAST": {
    "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/JoinSplit/JoinSplit.sol",
    "exportedSymbols": {
      "JoinSplit": [
        1109
      ],
      "JoinSplitInterface": [
        1095
      ]
    },
    "id": 1110,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1070,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:2"
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/JoinSplit/JoinSplitABIEncoder.sol",
        "file": "./JoinSplitABIEncoder.sol",
        "id": 1071,
        "nodeType": "ImportDirective",
        "scope": 1110,
        "sourceUnit": 1144,
        "src": "33:35:2",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/libs/LibEIP712.sol",
        "file": "../../../libs/LibEIP712.sol",
        "id": 1072,
        "nodeType": "ImportDirective",
        "scope": 1110,
        "sourceUnit": 1939,
        "src": "69:37:2",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 1073,
              "name": "LibEIP712",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 1938,
              "src": "139:9:2",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_LibEIP712_$1938",
                "typeString": "contract LibEIP712"
              }
            },
            "id": 1074,
            "nodeType": "InheritanceSpecifier",
            "src": "139:9:2"
          }
        ],
        "contractDependencies": [
          1938
        ],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 1095,
        "linearizedBaseContracts": [
          1095,
          1938
        ],
        "name": "JoinSplitInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "constant": false,
            "id": 1076,
            "name": "EIP712_DOMAIN_HASH",
            "nodeType": "VariableDeclaration",
            "scope": 1095,
            "src": "210:33:2",
            "stateVariable": true,
            "storageLocation": "default",
            "typeDescriptions": {
              "typeIdentifier": "t_bytes32",
              "typeString": "bytes32"
            },
            "typeName": {
              "id": 1075,
              "name": "bytes32",
              "nodeType": "ElementaryTypeName",
              "src": "210:7:2",
              "typeDescriptions": {
                "typeIdentifier": "t_bytes32",
                "typeString": "bytes32"
              }
            },
            "value": null,
            "visibility": "public"
          },
          {
            "body": {
              "id": 1079,
              "nodeType": "Block",
              "src": "271:2:2",
              "statements": []
            },
            "documentation": null,
            "id": 1080,
            "implemented": true,
            "kind": "constructor",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1077,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "261:2:2"
            },
            "returnParameters": {
              "id": 1078,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "271:0:2"
            },
            "scope": 1095,
            "src": "250:23:2",
            "stateMutability": "nonpayable",
            "superFunction": null,
            "visibility": "public"
          },
          {
            "body": {
              "id": 1093,
              "nodeType": "Block",
              "src": "454:2:2",
              "statements": []
            },
            "documentation": null,
            "id": 1094,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "validateJoinSplit",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1089,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1082,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "319:14:2",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1081,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "319:5:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1084,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "344:7:2",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 1083,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "344:7:2",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1088,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "362:16:2",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$6_calldata_ptr",
                    "typeString": "uint256[6]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 1085,
                      "name": "uint",
                      "nodeType": "ElementaryTypeName",
                      "src": "362:4:2",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 1087,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "36",
                      "id": 1086,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "367:1:2",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "6"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "362:7:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$6_storage_ptr",
                      "typeString": "uint256[6]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "309:75:2"
            },
            "returnParameters": {
              "id": 1092,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1091,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1094,
                  "src": "435:12:2",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1090,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "435:5:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "434:14:2"
            },
            "scope": 1095,
            "src": "283:173:2",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1110,
        "src": "108:350:2"
      },
      {
        "baseContracts": [
          {
            "arguments": null,
            "baseName": {
              "contractScope": null,
              "id": 1096,
              "name": "LibEIP712",
              "nodeType": "UserDefinedTypeName",
              "referencedDeclaration": 1938,
              "src": "1432:9:2",
              "typeDescriptions": {
                "typeIdentifier": "t_contract$_LibEIP712_$1938",
                "typeString": "contract LibEIP712"
              }
            },
            "id": 1097,
            "nodeType": "InheritanceSpecifier",
            "src": "1432:9:2"
          }
        ],
        "contractDependencies": [
          1938
        ],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC zero-knowledge proofs\n@author Zachary Williamson, AZTEC\n@dev Don't include this as an internal library. This contract uses a static memory table to cache\nelliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory mutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`.\nExternal calls to OptimizedAZTEC can be treated as pure functions as this contract contains no\nstorage and makes no external calls (other than to precompiles)\nCopyright Spilsbury Holdings Ltd 2018. All rights reserved.\nWe will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\nOur full vision of the protocol includes confidential cross-asset interactions via our\nfamily of AZTEC zero-knowledge proofs\nand the AZTEC token standard, stay tuned for updates!*",
        "fullyImplemented": true,
        "id": 1109,
        "linearizedBaseContracts": [
          1109,
          1938
        ],
        "name": "JoinSplit",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1107,
              "nodeType": "Block",
              "src": "2070:17076:2",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1100,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateJoinSplit()\n    function validateJoinSplit()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x184))\n        let m := calldataload(0x124)\n        let n := calldataload(notes)\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x144), gen_order)\n        if gt(m, n)\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n        let kn := calldataload(sub(add(notes, mul(calldataload(notes), 0xc0)), 0xa0))\n        mstore(0x2a0, calldataload(0x24))\n        mstore(0x2c0, kn)\n        mstore(0x2e0, m)\n        mstore(0x300, calldataload(0x164))\n        kn := mulmod(sub(gen_order, kn), challenge, gen_order)\n        hashCommitments(notes, n)\n        let b := add(0x320, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch eq(add(i, 0x01), n)\n            case 1 {\n                k := kn\n                if eq(m, n)\n                {\n                    k := sub(gen_order, k)\n                }\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            switch gt(add(i, 0x01), m)\n            case 1 {\n                kn := addmod(kn, sub(gen_order, k), gen_order)\n                let x := mod(mload(0x00), gen_order)\n                k := mulmod(k, x, gen_order)\n                a := mulmod(a, x, gen_order)\n                c := mulmod(challenge, x, gen_order)\n                mstore(0x00, keccak256(0x00, 0x20))\n            }\n            case 0 {\n                kn := addmod(kn, k, gen_order)\n            }\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, m)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, m)\n            {\n                mstore(0x60, c)\n                result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        if lt(m, n)\n        {\n            validatePairing(0x84)\n        }\n        let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x320, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x320, mul(n, 0x80)))\n    }\n}",
                  "src": "2080:17025:2"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [
                      {
                        "argumentTypes": null,
                        "id": 1104,
                        "name": "EIP712_DOMAIN_HASH",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1864,
                        "src": "19120:18:2",
                        "typeDescriptions": {
                          "typeIdentifier": "t_bytes32",
                          "typeString": "bytes32"
                        }
                      }
                    ],
                    "expression": {
                      "argumentTypes": [
                        {
                          "typeIdentifier": "t_bytes32",
                          "typeString": "bytes32"
                        }
                      ],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1101,
                        "name": "JoinSplitABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1120,
                        "src": "19086:19:2",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_JoinSplitABIEncoder_$1120_$",
                          "typeString": "type(library JoinSplitABIEncoder)"
                        }
                      },
                      "id": 1103,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1119,
                      "src": "19086:33:2",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_view$_t_bytes32_$returns$__$",
                        "typeString": "function (bytes32) view"
                      }
                    },
                    "id": 1105,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "19086:53:2",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1106,
                  "nodeType": "ExpressionStatement",
                  "src": "19086:53:2"
                }
              ]
            },
            "documentation": "@dev AZTEC will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction will throw.\n@notice See AZTECInterface for how method calls should be constructed.\n'Cost' of raw elliptic curve primitives for a transaction:\n260,700 gas + (124,500 * number of input notes) + (167,600 * number of output notes).\nFor a basic 'joinSplit' with 2 inputs and 2 outputs = 844,900 gas.\nAZTEC is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1108,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1098,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "2050:2:2"
            },
            "returnParameters": {
              "id": 1099,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "2070:0:2"
            },
            "scope": 1109,
            "src": "2042:17104:2",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1110,
        "src": "1410:17738:2"
      }
    ],
    "src": "0:19149:2"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.4+commit.9549d8ff.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.2",
  "updatedAt": "2019-03-03T05:16:20.282Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}