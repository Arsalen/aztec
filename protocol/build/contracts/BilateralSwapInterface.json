{
  "contractName": "BilateralSwapInterface",
  "abi": [
    {
      "constant": true,
      "inputs": [
        {
          "name": "",
          "type": "bytes"
        },
        {
          "name": "",
          "type": "address"
        },
        {
          "name": "",
          "type": "uint256[6]"
        }
      ],
      "name": "validateBilateralSwap",
      "outputs": [
        {
          "name": "",
          "type": "bytes"
        }
      ],
      "payable": false,
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "bytecode": "0x608060405234801561001057600080fd5b50610183806100206000396000f3fe608060405234801561001057600080fd5b5060043610610047577c010000000000000000000000000000000000000000000000000000000060003504636b9cc11d811461004c575b600080fd5b6100d8600480360361010081101561006357600080fd5b81019060208101813564010000000081111561007e57600080fd5b82018360208201111561009057600080fd5b803590602001918460018302840111640100000000831117156100b257600080fd5b919350915073ffffffffffffffffffffffffffffffffffffffff8135169060200161014d565b6040805160208082528351818301528351919283929083019185019080838360005b838110156101125781810151838201526020016100fa565b50505050905090810190601f16801561013f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b606094935050505056fea165627a7a72305820209ee196db7fc793c6c72f1ca4637497056154632528fe8185a5a2ee27c5583b0029",
  "deployedBytecode": "0x608060405234801561001057600080fd5b5060043610610047577c010000000000000000000000000000000000000000000000000000000060003504636b9cc11d811461004c575b600080fd5b6100d8600480360361010081101561006357600080fd5b81019060208101813564010000000081111561007e57600080fd5b82018360208201111561009057600080fd5b803590602001918460018302840111640100000000831117156100b257600080fd5b919350915073ffffffffffffffffffffffffffffffffffffffff8135169060200161014d565b6040805160208082528351818301528351919283929083019185019080838360005b838110156101125781810151838201526020016100fa565b50505050905090810190601f16801561013f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b606094935050505056fea165627a7a72305820209ee196db7fc793c6c72f1ca4637497056154632528fe8185a5a2ee27c5583b0029",
  "sourceMap": "74:221:4:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;74:221:4;;;;;;;",
  "deployedSourceMap": "74:221:4:-;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;74:221:4;;;;;;;;;;;;;;;;;;;116:177;;;;;;13:3:-1;8;5:12;2:2;;;30:1;27;20:12;2:2;116:177:4;;;;;;;;21:11:-1;5:28;;2:2;;;46:1;43;36:12;2:2;116:177:4;;35:9:-1;28:4;12:14;8:25;5:40;2:2;;;58:1;55;48:12;2:2;116:177:4;;;;;;100:9:-1;95:1;81:12;77:20;67:8;63:35;60:50;39:11;25:12;22:29;11:107;8:2;;;131:1;128;121:12;8:2;116:177:4;;-1:-1:-1;116:177:4;-1:-1:-1;116:177:4;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8:100:-1;33:3;30:1;27:10;8:100;;;90:11;;;84:18;71:11;;;64:39;52:2;45:10;8:100;;;12:14;116:177:4;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;272:12;116:177;;;;;;:::o",
  "source": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./BilateralSwapABIEncoder.sol\";\n\ncontract BilateralSwapInterface {    \n    function validateBilateralSwap(\n        bytes calldata, \n        address, \n        uint[6] calldata\n    ) \n        external \n        pure \n        returns (bytes memory) \n    {}\n}\n\n\n/**\n * @title Library to validate AZTEC Bilateral Swap zero-knowledge proofs\n * @author AZTEC\n * @dev Don't include this as an internal library. This contract uses \n * a static memory table to cache elliptic curve primitives and hashes.\n * Calling this internally from another function will lead to memory \n * mutation and undefined behaviour.\n * The intended use case is to call this externally via `staticcall`. External \n * calls to OptimizedAZTEC can be treated as pure functions as this contract \n * contains no storage and makes no external calls (other than to precompiles)\n * Copyright Spilbury Holdings Ltd 2018. All rights reserved.\n **/\ncontract BilateralSwap {\n\n    /**\n     * @dev AZTECBilateralSwap will take any transaction sent to it and attempt to validate a zero knowledge proof.\n     * If the proof is not valid, the transaction will throw.\n     * @notice See BilateralSwapInterface for how method calls should be constructed.\n     * AZTECBilateralSwap is written in YUL to enable manual memory management and for other efficiency savings.\n     **/\n    function() external payable {\n        assembly {\n\n            // We don't check for function signatures, there's only one function that \n            // ever gets called: validateBilateralSwap()\n            // We still assume calldata is offset by 4 bytes so that we can represent \n            // this contract through a comp\\atible ABI\n            validateBilateralSwap()\n\n            /**\n             * New calldata map\n             * 0x04:0x24      = calldata location of proofData byte array \n             * 0x24:0x44      = message sender // sender\n             * 0x44:0x64      = h_x     // crs\n             * 0x64:0x84      = h_y     // crs\n             * 0x84:0xa4      = t2_x0   // crs\n             * 0xa4:0xc4      = t2_x1   // crs\n             * 0xa4:0xc4      = t2_x1   // crs\n             * 0xc4:0xe4      = t2_y0   // crs\n             * 0xe4:0x104     = t2_y1   // crs\n             * 0x104:0x124    = length of proofData byte array \n             * 0x124:0x144    = challenge\n             * 0x144:0x164    = offset in byte array to notes\n             * 0x164:0x184    = offset in byte array to inputOwners\n             * 0x184:0x1a4    = offset in byte array to outputOwners\n             * 0x1a4:0x1c4    = offset in byte array to metadata\n             *\n             *\n             * Note data map (uint[6]) is\n             * 0x00:0x20       = Z_p element \\bar{k}_i\n             * 0x20:0x40       = Z_p element \\bar{a}_i\n             * 0x40:0x80       = G1 element \\gamma_i\n             * 0x80:0xc0       = G1 element \\sigma_i\n             *\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an \n             * external contract then terrible things will happen!\n             *\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\n             * 0x80:0xc0       = x-coordinate of generator h\n             * 0xc0:0xe0       = y-coordinate of generator h\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\n             * 0x2e0:0x300     = msg.sender (contract should be called via delegatecall/staticcall)\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1} \n             *                   concatenated with (B_i)_{i=0}^{n-1}\n             **/\n            function validateBilateralSwap() {\n                /*\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\n                */\n\n                mstore(0x80, calldataload(0x44)) // h_x\n                mstore(0xa0, calldataload(0x64)) // h_y\n                let notes := add(0x104, calldataload(0x144)) // start position of notes\n                let n := calldataload(notes) // first element of the notes array is it's length\n\n                if iszero(eq(n, 0x04)) { // eq(n, 4) will resolve to 0 if n != 4\n\n                    mstore(0x00, 400) // 400 error code - due to incorrect number of notes supplied\n                    revert(0x00, 0x20)\n\n                }\n\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let challenge := mod(calldataload(0x124), gen_order)\n\n                mstore(0x2e0, calldataload(0x24)) // store the msg.sender, to be hashed later\n\n                hashCommitments(notes, n)\n                let b := add(0x300, mul(n, 0x80)) // set pointer to memory location of commitments where the commitments\n\n                /*\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\n                */\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n\n                    // Get the calldata index of this note and associated parameters\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n                    let k\n                    let a := calldataload(add(noteIndex, 0x20))\n                    let c := challenge\n\n                    switch gt(i, 1) // i (an indexer) > 1 denotes a taker note\n                    case 1 { // if it's a taker note\n\n                        // indexing the k value of the note that is 2 indices behind the current note\n                        k := calldataload(sub(noteIndex, 0x180))\n                    } \n                        \n                    case 0 { // if it's a maker note\n                        k := calldataload(noteIndex)\n                    }\n\n\n                    // Check this commitment is well formed\n                    validateCommitment(noteIndex, k, a)\n                    \n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\n                    // Memory map:\n                    // 0x20: \\gamma_iX\n                    // 0x40: \\gamma_iY\n                    // 0x60: k_i\n                    // 0x80: hX\n                    // 0xa0: hY\n                    // 0xc0: a_i\n                    // 0xe0: \\sigma_iX\n                    // 0x100: \\sigma_iY\n                    // 0x120: -c\n\n                    // loading into memory\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n                    mstore(0x120, sub(gen_order, c)) \n                    mstore(0x60, k)\n                    mstore(0xc0, a)\n\n                    // Call bn128 scalar multiplication precompiles\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n                    // Store \\gamma_i^{k} at 0x120:0x160\n                    // Store h^{a} at 0x160:0x1a0\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\n\n                    // Call bn128 group addition precompiles\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n                    // Store result of addition at 0x160:0x1a0\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n                    // Store resulting point B at memory index b\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n\n                    // throw transaction if any calls to precompiled contracts failed\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n                    b := add(b, 0x40) // increase B pointer by 2 words\n                }\n                // Both bid notes already exist in their revelant AZTEC note registries - so can inductively \n                // infer that the ask notes are in the required range\n                // Therefore, don't need a range proof\n            \n                /*\n                ////////////////////  RECONSTRUCT INITIAL CHALLENGE AND VERIFY A MATCH  ////////////////////////////////\n                */\n\n                // We now have the note commitments and the calculated blinding factors in a block of memory\n                // starting at 0x2e0, of size (b - 0x2e0).\n                // Hash this block to reconstruct the initial challenge and validate that they match\n                let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n\n                if iszero(eq(expected, challenge)) {\n\n                    // No! Bad! No soup for you!\n                    mstore(0x00, 404)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction\n             * will throw if this is not the case.\n             * @param note the calldata loation of the note\n             **/\n            function validateCommitment(note, k, a) {\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let gammaX := calldataload(add(note, 0x40))\n                let gammaY := calldataload(add(note, 0x60))\n                let sigmaX := calldataload(add(note, 0x80))\n                let sigmaY := calldataload(add(note, 0xa0))\n                if iszero(\n                    and(\n                        and(\n                            and(\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n                                gt(a, 1)                  // can't be 0 or 1 either!\n                            ),\n                            and(\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n                                gt(k, 1)                  // and not 0 or 1\n                            )\n                        ),\n                        and(\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(\n                                    mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), \n                                    3, \n                                    field_order),\n                                mulmod(sigmaY, sigmaY, field_order)\n                            ),\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(mulmod(\n                                    mulmod(gammaX, gammaX, field_order), \n                                    gammaX, \n                                    field_order), \n                                    3, field_order),\n                                mulmod(gammaY, gammaY, field_order)\n                            )\n                        )\n                    )\n                ) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev Calculate the keccak256 hash of the commitments for both \n             * input notes and output notes. This is used both as an input to \n             * validate the challenge `c` and also to generate pseudorandom relationships\n             * between commitments for different outputNotes, so that we can combine \n             * them into a single multi-exponentiation for the purposes of validating \n             * the bilinear pairing relationships.\n             * @param notes calldata location notes\n             * @param n number of notes\n             **/\n            function hashCommitments(notes, n) {\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\n                let index := add(add(notes, mul(i, 0xc0)), 0x60)\n                calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n                }\n                // storing at position 0x00 in memory, the kecca hash of everything from \n                // start of the commitments to the end\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n            }\n        }\n        // if we've reached here, we've validated the bilateral swap and haven't thrown an error.\n        // Encode the output according to the ACE standard and exit.\n        BilateralSwapABIEncoder.encodeAndExit();\n    }\n}\n",
  "sourcePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwap.sol",
  "ast": {
    "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwap.sol",
    "exportedSymbols": {
      "BilateralSwap": [
        1172
      ],
      "BilateralSwapInterface": [
        1161
      ]
    },
    "id": 1173,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1145,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:4"
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwapABIEncoder.sol",
        "file": "./BilateralSwapABIEncoder.sol",
        "id": 1146,
        "nodeType": "ImportDirective",
        "scope": 1173,
        "sourceUnit": 1201,
        "src": "33:39:4",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 1161,
        "linearizedBaseContracts": [
          1161
        ],
        "name": "BilateralSwapInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1159,
              "nodeType": "Block",
              "src": "291:2:4",
              "statements": []
            },
            "documentation": null,
            "id": 1160,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "validateBilateralSwap",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1155,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1148,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "156:14:4",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1147,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "156:5:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1150,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "181:7:4",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 1149,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "181:7:4",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1154,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "199:16:4",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$6_calldata_ptr",
                    "typeString": "uint256[6]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 1151,
                      "name": "uint",
                      "nodeType": "ElementaryTypeName",
                      "src": "199:4:4",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 1153,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "36",
                      "id": 1152,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "204:1:4",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "6"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "199:7:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$6_storage_ptr",
                      "typeString": "uint256[6]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "146:75:4"
            },
            "returnParameters": {
              "id": 1158,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1157,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "272:12:4",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1156,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "272:5:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "271:14:4"
            },
            "scope": 1161,
            "src": "116:177:4",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1173,
        "src": "74:221:4"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC Bilateral Swap zero-knowledge proofs\n@author AZTEC\n@dev Don't include this as an internal library. This contract uses \na static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory \nmutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External \ncalls to OptimizedAZTEC can be treated as pure functions as this contract \ncontains no storage and makes no external calls (other than to precompiles)\nCopyright Spilbury Holdings Ltd 2018. All rights reserved.*",
        "fullyImplemented": true,
        "id": 1172,
        "linearizedBaseContracts": [
          1172
        ],
        "name": "BilateralSwap",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1170,
              "nodeType": "Block",
              "src": "1398:11924:4",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1164,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateBilateralSwap()\n    function validateBilateralSwap()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x144))\n        let n := calldataload(notes)\n        if iszero(eq(n, 0x04))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        mstore(0x2e0, calldataload(0x24))\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 1)\n            case 1 {\n                k := calldataload(sub(noteIndex, 0x180))\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}",
                  "src": "1408:11891:4"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [],
                    "expression": {
                      "argumentTypes": [],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1165,
                        "name": "BilateralSwapABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1180,
                        "src": "13276:23:4",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_BilateralSwapABIEncoder_$1180_$",
                          "typeString": "type(library BilateralSwapABIEncoder)"
                        }
                      },
                      "id": 1167,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1179,
                      "src": "13276:37:4",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$__$returns$__$",
                        "typeString": "function () pure"
                      }
                    },
                    "id": 1168,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "13276:39:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1169,
                  "nodeType": "ExpressionStatement",
                  "src": "13276:39:4"
                }
              ]
            },
            "documentation": "@dev AZTECBilateralSwap will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction will throw.\n@notice See BilateralSwapInterface for how method calls should be constructed.\nAZTECBilateralSwap is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1171,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1162,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1378:2:4"
            },
            "returnParameters": {
              "id": 1163,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1398:0:4"
            },
            "scope": 1172,
            "src": "1370:11952:4",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1173,
        "src": "946:12378:4"
      }
    ],
    "src": "0:13325:4"
  },
  "legacyAST": {
    "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwap.sol",
    "exportedSymbols": {
      "BilateralSwap": [
        1172
      ],
      "BilateralSwapInterface": [
        1161
      ]
    },
    "id": 1173,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1145,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:4"
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/bilateralSwap/BilateralSwapABIEncoder.sol",
        "file": "./BilateralSwapABIEncoder.sol",
        "id": 1146,
        "nodeType": "ImportDirective",
        "scope": 1173,
        "sourceUnit": 1201,
        "src": "33:39:4",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": null,
        "fullyImplemented": true,
        "id": 1161,
        "linearizedBaseContracts": [
          1161
        ],
        "name": "BilateralSwapInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1159,
              "nodeType": "Block",
              "src": "291:2:4",
              "statements": []
            },
            "documentation": null,
            "id": 1160,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "validateBilateralSwap",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1155,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1148,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "156:14:4",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1147,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "156:5:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1150,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "181:7:4",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 1149,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "181:7:4",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1154,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "199:16:4",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$6_calldata_ptr",
                    "typeString": "uint256[6]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 1151,
                      "name": "uint",
                      "nodeType": "ElementaryTypeName",
                      "src": "199:4:4",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 1153,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "36",
                      "id": 1152,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "204:1:4",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "6"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "199:7:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$6_storage_ptr",
                      "typeString": "uint256[6]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "146:75:4"
            },
            "returnParameters": {
              "id": 1158,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1157,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1160,
                  "src": "272:12:4",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1156,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "272:5:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "271:14:4"
            },
            "scope": 1161,
            "src": "116:177:4",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1173,
        "src": "74:221:4"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC Bilateral Swap zero-knowledge proofs\n@author AZTEC\n@dev Don't include this as an internal library. This contract uses \na static memory table to cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory \nmutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External \ncalls to OptimizedAZTEC can be treated as pure functions as this contract \ncontains no storage and makes no external calls (other than to precompiles)\nCopyright Spilbury Holdings Ltd 2018. All rights reserved.*",
        "fullyImplemented": true,
        "id": 1172,
        "linearizedBaseContracts": [
          1172
        ],
        "name": "BilateralSwap",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1170,
              "nodeType": "Block",
              "src": "1398:11924:4",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1164,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateBilateralSwap()\n    function validateBilateralSwap()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x144))\n        let n := calldataload(notes)\n        if iszero(eq(n, 0x04))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        mstore(0x2e0, calldataload(0x24))\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 1)\n            case 1 {\n                k := calldataload(sub(noteIndex, 0x180))\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            validateCommitment(noteIndex, k, a)\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        let expected := mod(keccak256(0x2e0, sub(b, 0x2e0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}",
                  "src": "1408:11891:4"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [],
                    "expression": {
                      "argumentTypes": [],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1165,
                        "name": "BilateralSwapABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1180,
                        "src": "13276:23:4",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_BilateralSwapABIEncoder_$1180_$",
                          "typeString": "type(library BilateralSwapABIEncoder)"
                        }
                      },
                      "id": 1167,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1179,
                      "src": "13276:37:4",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$__$returns$__$",
                        "typeString": "function () pure"
                      }
                    },
                    "id": 1168,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "13276:39:4",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1169,
                  "nodeType": "ExpressionStatement",
                  "src": "13276:39:4"
                }
              ]
            },
            "documentation": "@dev AZTECBilateralSwap will take any transaction sent to it and attempt to validate a zero knowledge proof.\nIf the proof is not valid, the transaction will throw.\n@notice See BilateralSwapInterface for how method calls should be constructed.\nAZTECBilateralSwap is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1171,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1162,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1378:2:4"
            },
            "returnParameters": {
              "id": 1163,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1398:0:4"
            },
            "scope": 1172,
            "src": "1370:11952:4",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1173,
        "src": "946:12378:4"
      }
    ],
    "src": "0:13325:4"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.4+commit.9549d8ff.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.2",
  "updatedAt": "2019-03-03T05:16:18.507Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}