{
  "contractName": "DividendComputationInterface",
  "abi": [
    {
      "constant": true,
      "inputs": [
        {
          "name": "",
          "type": "bytes"
        },
        {
          "name": "",
          "type": "address"
        },
        {
          "name": "",
          "type": "uint256[6]"
        }
      ],
      "name": "validateDividendComputation",
      "outputs": [
        {
          "name": "",
          "type": "bytes"
        }
      ],
      "payable": false,
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "bytecode": "0x61018d610030600b82828239805160001a6073146000811461002057610022565bfe5b5030600052607381538281f3fe7300000000000000000000000000000000000000003014608060405260043610610051577c01000000000000000000000000000000000000000000000000000000006000350463484b99d58114610056575b600080fd5b6100e2600480360361010081101561006d57600080fd5b81019060208101813564010000000081111561008857600080fd5b82018360208201111561009a57600080fd5b803590602001918460018302840111640100000000831117156100bc57600080fd5b919350915073ffffffffffffffffffffffffffffffffffffffff81351690602001610157565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561011c578181015183820152602001610104565b50505050905090810190601f1680156101495780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b606094935050505056fea165627a7a723058204ddc889f1b3f074c745fd88f928091a9be86f2b2058dbfdcb000be4b7d8e58570029",
  "deployedBytecode": "0x7300000000000000000000000000000000000000003014608060405260043610610051577c01000000000000000000000000000000000000000000000000000000006000350463484b99d58114610056575b600080fd5b6100e2600480360361010081101561006d57600080fd5b81019060208101813564010000000081111561008857600080fd5b82018360208201111561009a57600080fd5b803590602001918460018302840111640100000000831117156100bc57600080fd5b919350915073ffffffffffffffffffffffffffffffffffffffff81351690602001610157565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561011c578181015183820152602001610104565b50505050905090810190601f1680156101495780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b606094935050505056fea165627a7a723058204ddc889f1b3f074c745fd88f928091a9be86f2b2058dbfdcb000be4b7d8e58570029",
  "sourceMap": "81:224:6:-;;132:2:-1;166:7;155:9;146:7;137:37;252:7;246:14;243:1;238:23;232:4;229:33;270:1;265:20;;;;222:63;;265:20;274:9;222:63;;298:9;295:1;288:20;328:4;319:7;311:22;352:7;343;336:24",
  "deployedSourceMap": "81:224:6:-;;;;;;;;;;;;;;;;;;;;;;;;124:179;;;;;;13:3:-1;8;5:12;2:2;;;30:1;27;20:12;2:2;124:179:6;;;;;;;;21:11:-1;5:28;;2:2;;;46:1;43;36:12;2:2;124:179:6;;35:9:-1;28:4;12:14;8:25;5:40;2:2;;;58:1;55;48:12;2:2;124:179:6;;;;;;100:9:-1;95:1;81:12;77:20;67:8;63:35;60:50;39:11;25:12;22:29;11:107;8:2;;;131:1;128;121:12;8:2;124:179:6;;-1:-1:-1;124:179:6;-1:-1:-1;124:179:6;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8:100:-1;33:3;30:1;27:10;8:100;;;90:11;;;84:18;71:11;;;64:39;52:2;45:10;8:100;;;12:14;124:179:6;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;282:12;124:179;;;;;;:::o",
  "source": "pragma solidity >=0.5.0 <0.6.0;\n\nimport \"./DividendComputationABIEncoder.sol\";\n\n\nlibrary DividendComputationInterface {\n    function validateDividendComputation(\n        bytes calldata,\n        address,\n        uint[6] calldata\n    ) \n        external\n        pure\n        returns (bytes memory) \n    {}\n}\n\n/**\n * @title Library to validate AZTEC dividend computation proofs\n * @author AZTEC\n * @dev Don't include this as an internal library. This contract uses a static memory table \n * to cache elliptic curve primitives and hashes.\n * Calling this internally from another function will lead to memory mutation and undefined behaviour.\n * The intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC \n * can be treated as pure functions as this contract contains no storage and makes no external calls \n * (other than to precompiles).\n * Copyright Spilbury Holdings Ltd 2018. All rights reserved.\n **/\ncontract DividendComputation {\n    /**\n     * @dev This will take any dividend calculation proof data and attempt to verify it in zero-knowledge\n     * If the proof is not valid, the transaction will throw.\n     * @notice See DividendComputationInterface for how method calls should be constructed.\n     * DividendComputation is written in YUL to enable manual memory management and for other efficiency savings.\n     **/\n    function() external payable {\n        assembly {\n\n            // We don't check for function signatures, there's only one function \n            // that ever gets called: validateDividendCalc()\n            // We still assume calldata is offset by 4 bytes so that we can \n            // represent this contract through a compatible ABI\n            validateDividendComputation()\n\n            /**\n             * New calldata map\n             * 0x04:0x24      = calldata location of proofData byte array  // proof data byte array\n             * 0x24:0x44      = message sender // address\n             * 0x44:0x64      = h_x     // crs\n             * 0x64:0x84      = h_y     // crs\n             * 0x84:0xa4      = t2_x0   // crs\n             * 0xa4:0xc4      = t2_x1   // crs\n             * 0xc4:0xe4      = t2_y0   // crs\n             * 0xe4:0x104     = t2_y1   // crs\n             * 0x104:0x124    = length of proofData byte array\n             * 0x124:0x144    = challenge\n             * 0x144:0x164    = za\n             * 0x164:0x184    = zb\n             * 0x184:0x1a4    = offset in byte array to notes\n             * 0x1a4:0x1c4    = offset in byte array to inputOwners\n             * 0x1c4:0x1e4    = offset in byte array to outputOwners\n             * 0x1e4:0x204    = offset in byte array to metadata\n             */ \n\n            function validateDividendComputation() {\n                \n                /*\n                ///////////////////////////////////////////  SETUP  //////////////////////////////////////////////\n                */\n                mstore(0x80, calldataload(0x44))\n                mstore(0xa0, calldataload(0x64))\n                let notes := add(0x104, calldataload(0x184))\n                let n := calldataload(notes)\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001                \n                let challenge := mod(calldataload(0x124), gen_order)\n\n                let za := mod(calldataload(0x144), gen_order)\n                let zb := mod(calldataload(0x164), gen_order)\n\n\n                // Check that za < kMax\n                if gt(za, 1048576) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n\n                // Check that zb < kMax\n                if gt(zb, 1048576) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n\n                /*\n                m is the deliminator between input and output notes. \n                We only have one input note, and then the next two are output notes.\n\n                m = 0 and n = 3\n\n                Variables not defined and instead hard-coded, to save on stack depth\n                */\n\n                // add caller, za and zb to final hash table\n                mstore(0x2a0, calldataload(0x24))\n                mstore(0x2c0, za)\n                mstore(0x2e0, zb)\n\n                hashCommitments(notes, n) \n                let b := add(0x300, mul(n, 0x80)) \n\n                /*\n                ///////////////////////////  CALCULATE BLINDING FACTORS  /////////////////////////////////////\n                */\n\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1.\n                // This adds some minor alterations\n                for { let i := 0 } lt(i, 3) { i := add(i, 0x01) } {\n\n                    // Get the calldata index of this note - call data location of start of note\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n\n                    // Define variables k, a and c.\n                    // If i <= m then - input notes\n                    //   k = kBar_i\n                    //   a = aBar_i\n                    //   c = challenge\n                    // If i > m then we add a modification for the pairing optimization\n                    //   k = kBar_i * x_i\n                    //   a = aBar_i * x_i\n                    //   c = challenge * x_i\n                    // Set j = i - (m + 1). - index to count the output commitment\n                    // x_0 = 1\n                    // x_1 = keccak256(input string)\n                    // all other x_{j} = keccak256(x_{j-1})\n                    // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\n                    // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\n                    // We instead validate:\n                    // e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\n                    // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\n                    // a sum of commitment points to be evaluated in one pairing comparison\n\n                    let k\n                    let a := calldataload(add(noteIndex, 0x20))\n                    let c := challenge\n\n                    switch gt(i, 1)\n                    case 1 { // output note\n                        /*\n                        Enforce the condition k_3 = (k_1)(z_b) - (k_2)(z_a)\n                        */\n                        k := addmod(\n                                    mulmod(\n                                        calldataload(sub(noteIndex, add(0xc0, 0xc0))),\n                                        zb,\n                                        gen_order), // k_1 * z_b\n                                    mulmod(\n                                        sub(gen_order, calldataload(sub(noteIndex, 0xc0))),\n                                        za,\n                                        gen_order), //-(k_2 * z_a)\n                                    gen_order)       \n                    }\n\n                    case 0 { // input note\n                        /*\n                        Input commitments just have the k factors as according to the note data\n                        */  \n                        k := calldataload(noteIndex)\n                    }\n\n\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\n                    let x := mod(mload(0x00), gen_order) // x is the kecca hash of the input commitments\n                    k := mulmod(k, x, gen_order) // kx\n                    a := mulmod(a, x, gen_order) // ax\n                    c := mulmod(challenge, x, gen_order) // cx\n                    // calculate x_{j+1}\n                    mstore(0x00, keccak256(0x00, 0x20)) // rehashing the kecca hash, for use in the next x\n\n\n                    // Check this commitment is well formed\n                    validateCommitment(noteIndex, k, a)\n\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i - already has all x stuff\n                    // Memory map:\n                    // 0x20: \\gamma_iX\n                    // 0x40: \\gamma_iY\n                    // 0x60: k_i\n                    // 0x80: hX\n                    // 0xa0: hY\n                    // 0xc0: a_i\n                    // 0xe0: \\sigma_iX\n                    // 0x100: \\sigma_iY\n                    // 0x120: -c\n\n                    // loading key variables into memory to be operated on later\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)  \n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n                    mstore(0x120, sub(gen_order, c))\n                    mstore(0x60, k) \n                    mstore(0xc0, a)\n\n                    // Call bn128 scalar multiplication precompiles\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\n                    // Store \\gamma_i^{k} at 0x120:0x160\n                    // Store h^{a} at 0x160:0x1a0\n                    \n                    // result is a boolean. It keeps track of whether the call to the pre-compile was \n                    // successful. True if it was, False if it wasn't\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40) // sigma_i^{-c}\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40)) // gamma_i^{k}\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40)) // h^{a}\n\n                    // Call bn128 group addition precompiles\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\n                    // Store result of addition at 0x160:0x1a0\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\n\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\n                    // Store resulting point B at memory index b\n                    // index b points to the end of the block of memory containing commitments\n                    // we're appending blinding factors to the end of the commitment block\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\n\n                    // We have \\sigma^{-c} at 0x1a0:0x200\n                    // And \\sigma_{acc} at 0x1e0:0x200\n                    // If i = m + 1 (i.e. first output note)\n                    // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\n                    // the accumulator is the variable that is used to condense the various pairing\n                    // comparisons into a single one\n                    if eq(i, 0) { // m = 0\n                        mstore(0x260, mload(0x20))\n                        mstore(0x280, mload(0x40))\n                        mstore(0x1e0, mload(0xe0))\n                        mstore(\n                            0x200,\n                            sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100))\n                            )\n                    }\n\n                    // If i > m + 1 (i.e. subsequent output notes)\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\n                    if gt(i, 0) { // m = 0\n                        mstore(0x60, c)\n                        result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\n\n                       // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\n                        result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\n\n                       // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\n                        result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\n                    }\n\n                    // throw transaction if any calls to precompiled contracts failed\n                    if iszero(result) { mstore(0x00, 400) revert(0x00, 0x20) }\n                    b := add(b, 0x40) // increase B pointer by 2 words\n                }\n                \n\n                    validatePairing(0x84)\n\n                // We now have the message sender, z_a, z_b, note commitments and the \n                // calculated blinding factors in a block of memory starting at 0x2a0, of size (b - 0x2a0).\n                // Hash this block to reconstruct the initial challenge and validate that they match\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n\n\n                if iszero(eq(expected, challenge)) {\n                    \n                    // Proof failed\n                    mstore(0x00, 404)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**        \n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\n             * @notice we don't hard-code t2 so that contracts that call this library can use different trusted setups.\n             **/\n            function validatePairing(t2) {\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let t2_x_1 := calldataload(t2)\n                let t2_x_2 := calldataload(add(t2, 0x20))\n                let t2_y_1 := calldataload(add(t2, 0x40))\n                let t2_y_2 := calldataload(add(t2, 0x60))\n\n                // check provided setup pubkey is not zero or g2\n                if or(or(or(or(or(or(or(\n                    iszero(t2_x_1),\n                    iszero(t2_x_2)),\n                    iszero(t2_y_1)),\n                    iszero(t2_y_2)),\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n                {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n\n                // store coords in memory\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite\n                // to what precompile expects. We can overwrite the memory we used previously as this function\n                // is called at the end of the validation routine.\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\n                mstore(0x40, mload(0x200)) // sigma accumulator y\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\n                mstore(0x100, mload(0x280)) // gamma accumulator y\n                mstore(0x140, t2_x_1)\n                mstore(0x120, t2_x_2)\n                mstore(0x180, t2_y_1)\n                mstore(0x160, t2_y_2)\n\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\n\n                if or(iszero(success), iszero(mload(0x20))) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\n             * and that signatures 'k' and 'a' are modulo the order of the curve. \n             * Transaction will throw if this is not the case.\n             * @param note the calldata loation of the note\n             **/\n            function validateCommitment(note, k, a) {\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n                let gammaX := calldataload(add(note, 0x40))\n                let gammaY := calldataload(add(note, 0x60))\n                let sigmaX := calldataload(add(note, 0x80))\n                let sigmaY := calldataload(add(note, 0xa0))\n                if iszero(\n                    and(\n                        and(\n                            and(\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\n                                gt(a, 1)                  // can't be 0 or 1 either!\n                            ),\n                            and(\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\n                                gt(k, 1)                  // and not 0 or 1\n                            )\n                        ),\n                        and(\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(\n                                    mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), \n                                    3, \n                                    field_order),\n                                mulmod(sigmaY, sigmaY, field_order)\n                            ),\n                            eq( // y^2 ?= x^3 + 3\n                                addmod(\n                                    mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order),\n                                    3,\n                                    field_order),\n                                mulmod(gammaY, gammaY, field_order)\n                            )\n                        )\n                    )\n                ) {\n                    mstore(0x00, 400)\n                    revert(0x00, 0x20)\n                }\n            }\n\n            /**\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\n             * This is used both as an input to validate the challenge `c` and also \n             * to generate pseudorandom relationships between commitments for different outputNotes, so \n             * that we can combine them into a single multi-exponentiation for the purposes of \n             * validating the bilinear pairing relationships.\n             * @param notes calldata location of notes\n             * @param n number of notes\n             * \n             * @notice\n             */\n\n            function hashCommitments(notes, n) {\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } { \n                    let index := add(add(notes, mul(i, 0xc0)), 0x60) \n                    calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n                }\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n            }\n        }\n\n        DividendComputationABIEncoder.encodeAndExit();\n    }\n}\n",
  "sourcePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/dividendComputation/DividendComputation.sol",
  "ast": {
    "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/dividendComputation/DividendComputation.sol",
    "exportedSymbols": {
      "DividendComputation": [
        1229
      ],
      "DividendComputationInterface": [
        1218
      ]
    },
    "id": 1230,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1202,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:6"
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/dividendComputation/DividendComputationABIEncoder.sol",
        "file": "./DividendComputationABIEncoder.sol",
        "id": 1203,
        "nodeType": "ImportDirective",
        "scope": 1230,
        "sourceUnit": 1258,
        "src": "33:45:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "library",
        "documentation": null,
        "fullyImplemented": true,
        "id": 1218,
        "linearizedBaseContracts": [
          1218
        ],
        "name": "DividendComputationInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1216,
              "nodeType": "Block",
              "src": "301:2:6",
              "statements": []
            },
            "documentation": null,
            "id": 1217,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "validateDividendComputation",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1212,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1205,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "170:14:6",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1204,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "170:5:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1207,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "194:7:6",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 1206,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "194:7:6",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1211,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "211:16:6",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$6_calldata_ptr",
                    "typeString": "uint256[6]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 1208,
                      "name": "uint",
                      "nodeType": "ElementaryTypeName",
                      "src": "211:4:6",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 1210,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "36",
                      "id": 1209,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "216:1:6",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "6"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "211:7:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$6_storage_ptr",
                      "typeString": "uint256[6]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "160:73:6"
            },
            "returnParameters": {
              "id": 1215,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1214,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "282:12:6",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1213,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "282:5:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "281:14:6"
            },
            "scope": 1218,
            "src": "124:179:6",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1230,
        "src": "81:224:6"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC dividend computation proofs\n@author AZTEC\n@dev Don't include this as an internal library. This contract uses a static memory table \nto cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory mutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC \ncan be treated as pure functions as this contract contains no storage and makes no external calls \n(other than to precompiles).\nCopyright Spilbury Holdings Ltd 2018. All rights reserved.*",
        "fullyImplemented": true,
        "id": 1229,
        "linearizedBaseContracts": [
          1229
        ],
        "name": "DividendComputation",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1227,
              "nodeType": "Block",
              "src": "1397:17777:6",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1221,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateDividendComputation()\n    function validateDividendComputation()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x184))\n        let n := calldataload(notes)\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        let za := mod(calldataload(0x144), gen_order)\n        let zb := mod(calldataload(0x164), gen_order)\n        if gt(za, 1048576)\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        if gt(zb, 1048576)\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x2a0, calldataload(0x24))\n        mstore(0x2c0, za)\n        mstore(0x2e0, zb)\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, 3)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 1)\n            case 1 {\n                k := addmod(mulmod(calldataload(sub(noteIndex, add(0xc0, 0xc0))), zb, gen_order), mulmod(sub(gen_order, calldataload(sub(noteIndex, 0xc0))), za, gen_order), gen_order)\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            let x := mod(mload(0x00), gen_order)\n            k := mulmod(k, x, gen_order)\n            a := mulmod(a, x, gen_order)\n            c := mulmod(challenge, x, gen_order)\n            mstore(0x00, keccak256(0x00, 0x20))\n            validateCommitment(noteIndex, k, a)\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, 0)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, 0)\n            {\n                mstore(0x60, c)\n                result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        validatePairing(0x84)\n        let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}",
                  "src": "1407:17744:6"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [],
                    "expression": {
                      "argumentTypes": [],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1222,
                        "name": "DividendComputationABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1237,
                        "src": "19122:29:6",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_DividendComputationABIEncoder_$1237_$",
                          "typeString": "type(library DividendComputationABIEncoder)"
                        }
                      },
                      "id": 1224,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1236,
                      "src": "19122:43:6",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$__$returns$__$",
                        "typeString": "function () pure"
                      }
                    },
                    "id": 1225,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "19122:45:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1226,
                  "nodeType": "ExpressionStatement",
                  "src": "19122:45:6"
                }
              ]
            },
            "documentation": "@dev This will take any dividend calculation proof data and attempt to verify it in zero-knowledge\nIf the proof is not valid, the transaction will throw.\n@notice See DividendComputationInterface for how method calls should be constructed.\nDividendComputation is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1228,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1219,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1377:2:6"
            },
            "returnParameters": {
              "id": 1220,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1397:0:6"
            },
            "scope": 1229,
            "src": "1369:17805:6",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1230,
        "src": "943:18233:6"
      }
    ],
    "src": "0:19177:6"
  },
  "legacyAST": {
    "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/dividendComputation/DividendComputation.sol",
    "exportedSymbols": {
      "DividendComputation": [
        1229
      ],
      "DividendComputationInterface": [
        1218
      ]
    },
    "id": 1230,
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "id": 1202,
        "literals": [
          "solidity",
          ">=",
          "0.5",
          ".0",
          "<",
          "0.6",
          ".0"
        ],
        "nodeType": "PragmaDirective",
        "src": "0:31:6"
      },
      {
        "absolutePath": "/home/arsalen/Desktop/draft/AZTECProtocol/aztec-demo-js/protocol/contracts/ACE/validators/dividendComputation/DividendComputationABIEncoder.sol",
        "file": "./DividendComputationABIEncoder.sol",
        "id": 1203,
        "nodeType": "ImportDirective",
        "scope": 1230,
        "sourceUnit": 1258,
        "src": "33:45:6",
        "symbolAliases": [],
        "unitAlias": ""
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "library",
        "documentation": null,
        "fullyImplemented": true,
        "id": 1218,
        "linearizedBaseContracts": [
          1218
        ],
        "name": "DividendComputationInterface",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1216,
              "nodeType": "Block",
              "src": "301:2:6",
              "statements": []
            },
            "documentation": null,
            "id": 1217,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "validateDividendComputation",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1212,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1205,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "170:14:6",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1204,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "170:5:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1207,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "194:7:6",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 1206,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "194:7:6",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                },
                {
                  "constant": false,
                  "id": 1211,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "211:16:6",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_array$_t_uint256_$6_calldata_ptr",
                    "typeString": "uint256[6]"
                  },
                  "typeName": {
                    "baseType": {
                      "id": 1208,
                      "name": "uint",
                      "nodeType": "ElementaryTypeName",
                      "src": "211:4:6",
                      "typeDescriptions": {
                        "typeIdentifier": "t_uint256",
                        "typeString": "uint256"
                      }
                    },
                    "id": 1210,
                    "length": {
                      "argumentTypes": null,
                      "hexValue": "36",
                      "id": 1209,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "kind": "number",
                      "lValueRequested": false,
                      "nodeType": "Literal",
                      "src": "216:1:6",
                      "subdenomination": null,
                      "typeDescriptions": {
                        "typeIdentifier": null,
                        "typeString": null
                      },
                      "value": "6"
                    },
                    "nodeType": "ArrayTypeName",
                    "src": "211:7:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_array$_t_uint256_$6_storage_ptr",
                      "typeString": "uint256[6]"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "160:73:6"
            },
            "returnParameters": {
              "id": 1215,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 1214,
                  "name": "",
                  "nodeType": "VariableDeclaration",
                  "scope": 1217,
                  "src": "282:12:6",
                  "stateVariable": false,
                  "storageLocation": "memory",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_memory_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 1213,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "282:5:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "value": null,
                  "visibility": "internal"
                }
              ],
              "src": "281:14:6"
            },
            "scope": 1218,
            "src": "124:179:6",
            "stateMutability": "pure",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1230,
        "src": "81:224:6"
      },
      {
        "baseContracts": [],
        "contractDependencies": [],
        "contractKind": "contract",
        "documentation": "@title Library to validate AZTEC dividend computation proofs\n@author AZTEC\n@dev Don't include this as an internal library. This contract uses a static memory table \nto cache elliptic curve primitives and hashes.\nCalling this internally from another function will lead to memory mutation and undefined behaviour.\nThe intended use case is to call this externally via `staticcall`. External calls to OptimizedAZTEC \ncan be treated as pure functions as this contract contains no storage and makes no external calls \n(other than to precompiles).\nCopyright Spilbury Holdings Ltd 2018. All rights reserved.*",
        "fullyImplemented": true,
        "id": 1229,
        "linearizedBaseContracts": [
          1229
        ],
        "name": "DividendComputation",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 1227,
              "nodeType": "Block",
              "src": "1397:17777:6",
              "statements": [
                {
                  "externalReferences": [],
                  "id": 1221,
                  "nodeType": "InlineAssembly",
                  "operations": "{\n    validateDividendComputation()\n    function validateDividendComputation()\n    {\n        mstore(0x80, calldataload(0x44))\n        mstore(0xa0, calldataload(0x64))\n        let notes := add(0x104, calldataload(0x184))\n        let n := calldataload(notes)\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let challenge := mod(calldataload(0x124), gen_order)\n        let za := mod(calldataload(0x144), gen_order)\n        let zb := mod(calldataload(0x164), gen_order)\n        if gt(za, 1048576)\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        if gt(zb, 1048576)\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x2a0, calldataload(0x24))\n        mstore(0x2c0, za)\n        mstore(0x2e0, zb)\n        hashCommitments(notes, n)\n        let b := add(0x300, mul(n, 0x80))\n        for {\n            let i := 0\n        }\n        lt(i, 3)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\n            let k\n            let a := calldataload(add(noteIndex, 0x20))\n            let c := challenge\n            switch gt(i, 1)\n            case 1 {\n                k := addmod(mulmod(calldataload(sub(noteIndex, add(0xc0, 0xc0))), zb, gen_order), mulmod(sub(gen_order, calldataload(sub(noteIndex, 0xc0))), za, gen_order), gen_order)\n            }\n            case 0 {\n                k := calldataload(noteIndex)\n            }\n            let x := mod(mload(0x00), gen_order)\n            k := mulmod(k, x, gen_order)\n            a := mulmod(a, x, gen_order)\n            c := mulmod(challenge, x, gen_order)\n            mstore(0x00, keccak256(0x00, 0x20))\n            validateCommitment(noteIndex, k, a)\n            calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\n            calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\n            mstore(0x120, sub(gen_order, c))\n            mstore(0x60, k)\n            mstore(0xc0, a)\n            let result := staticcall(gas(), 7, 0xe0, 0x60, 0x1a0, 0x40)\n            result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x120, 0x40))\n            result := and(result, staticcall(gas(), 7, 0x80, 0x60, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x120, 0x80, 0x160, 0x40))\n            result := and(result, staticcall(gas(), 6, 0x160, 0x80, b, 0x40))\n            if eq(i, 0)\n            {\n                mstore(0x260, mload(0x20))\n                mstore(0x280, mload(0x40))\n                mstore(0x1e0, mload(0xe0))\n                mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\n            }\n            if gt(i, 0)\n            {\n                mstore(0x60, c)\n                result := and(result, staticcall(gas(), 7, 0x20, 0x60, 0x220, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x220, 0x80, 0x260, 0x40))\n                result := and(result, staticcall(gas(), 6, 0x1a0, 0x80, 0x1e0, 0x40))\n            }\n            if iszero(result)\n            {\n                mstore(0x00, 400)\n                revert(0x00, 0x20)\n            }\n            b := add(b, 0x40)\n        }\n        validatePairing(0x84)\n        let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\n        if iszero(eq(expected, challenge))\n        {\n            mstore(0x00, 404)\n            revert(0x00, 0x20)\n        }\n    }\n    function validatePairing(t2)\n    {\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let t2_x_1 := calldataload(t2)\n        let t2_x_2 := calldataload(add(t2, 0x20))\n        let t2_y_1 := calldataload(add(t2, 0x40))\n        let t2_y_2 := calldataload(add(t2, 0x60))\n        if or(or(or(or(or(or(or(iszero(t2_x_1), iszero(t2_x_2)), iszero(t2_y_1)), iszero(t2_y_2)), eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)), eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)), eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)), eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n        mstore(0x20, mload(0x1e0))\n        mstore(0x40, mload(0x200))\n        mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\n        mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\n        mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\n        mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\n        mstore(0xe0, mload(0x260))\n        mstore(0x100, mload(0x280))\n        mstore(0x140, t2_x_1)\n        mstore(0x120, t2_x_2)\n        mstore(0x180, t2_y_1)\n        mstore(0x160, t2_y_2)\n        let success := staticcall(gas(), 8, 0x20, 0x180, 0x20, 0x20)\n        if or(iszero(success), iszero(mload(0x20)))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function validateCommitment(note, k, a)\n    {\n        let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\n        let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n        let gammaX := calldataload(add(note, 0x40))\n        let gammaY := calldataload(add(note, 0x60))\n        let sigmaX := calldataload(add(note, 0x80))\n        let sigmaY := calldataload(add(note, 0xa0))\n        if iszero(and(and(and(eq(mod(a, gen_order), a), gt(a, 1)), and(eq(mod(k, gen_order), k), gt(k, 1))), and(eq(addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order), mulmod(sigmaY, sigmaY, field_order)), eq(addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order), mulmod(gammaY, gammaY, field_order)))))\n        {\n            mstore(0x00, 400)\n            revert(0x00, 0x20)\n        }\n    }\n    function hashCommitments(notes, n)\n    {\n        for {\n            let i := 0\n        }\n        lt(i, n)\n        {\n            i := add(i, 0x01)\n        }\n        {\n            let index := add(add(notes, mul(i, 0xc0)), 0x60)\n            calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\n        }\n        mstore(0x00, keccak256(0x300, mul(n, 0x80)))\n    }\n}",
                  "src": "1407:17744:6"
                },
                {
                  "expression": {
                    "argumentTypes": null,
                    "arguments": [],
                    "expression": {
                      "argumentTypes": [],
                      "expression": {
                        "argumentTypes": null,
                        "id": 1222,
                        "name": "DividendComputationABIEncoder",
                        "nodeType": "Identifier",
                        "overloadedDeclarations": [],
                        "referencedDeclaration": 1237,
                        "src": "19122:29:6",
                        "typeDescriptions": {
                          "typeIdentifier": "t_type$_t_contract$_DividendComputationABIEncoder_$1237_$",
                          "typeString": "type(library DividendComputationABIEncoder)"
                        }
                      },
                      "id": 1224,
                      "isConstant": false,
                      "isLValue": false,
                      "isPure": false,
                      "lValueRequested": false,
                      "memberName": "encodeAndExit",
                      "nodeType": "MemberAccess",
                      "referencedDeclaration": 1236,
                      "src": "19122:43:6",
                      "typeDescriptions": {
                        "typeIdentifier": "t_function_internal_pure$__$returns$__$",
                        "typeString": "function () pure"
                      }
                    },
                    "id": 1225,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "kind": "functionCall",
                    "lValueRequested": false,
                    "names": [],
                    "nodeType": "FunctionCall",
                    "src": "19122:45:6",
                    "typeDescriptions": {
                      "typeIdentifier": "t_tuple$__$",
                      "typeString": "tuple()"
                    }
                  },
                  "id": 1226,
                  "nodeType": "ExpressionStatement",
                  "src": "19122:45:6"
                }
              ]
            },
            "documentation": "@dev This will take any dividend calculation proof data and attempt to verify it in zero-knowledge\nIf the proof is not valid, the transaction will throw.\n@notice See DividendComputationInterface for how method calls should be constructed.\nDividendComputation is written in YUL to enable manual memory management and for other efficiency savings.*",
            "id": 1228,
            "implemented": true,
            "kind": "fallback",
            "modifiers": [],
            "name": "",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 1219,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1377:2:6"
            },
            "returnParameters": {
              "id": 1220,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "1397:0:6"
            },
            "scope": 1229,
            "src": "1369:17805:6",
            "stateMutability": "payable",
            "superFunction": null,
            "visibility": "external"
          }
        ],
        "scope": 1230,
        "src": "943:18233:6"
      }
    ],
    "src": "0:19177:6"
  },
  "compiler": {
    "name": "solc",
    "version": "0.5.4+commit.9549d8ff.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.2",
  "updatedAt": "2019-03-03T05:16:18.509Z",
  "devdoc": {
    "methods": {}
  },
  "userdoc": {
    "methods": {}
  }
}